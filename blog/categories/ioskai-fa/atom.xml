<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS开发 | 11IT]]></title>
  <link href="http://www.11it.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://www.11it.com/"/>
  <updated>2013-05-22T16:11:14+08:00</updated>
  <id>http://www.11it.com/</id>
  <author>
    <name><![CDATA[Jacky]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[再见，viewDidUnload方法]]></title>
    <link href="http://www.11it.com/blog/2013/05/22/zai-jian-%2Cviewdidunloadfang-fa/"/>
    <updated>2013-05-22T15:59:00+08:00</updated>
    <id>http://www.11it.com/blog/2013/05/22/zai-jian-,viewdidunloadfang-fa</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>我在去年的一篇文章《iOS5中UIViewController的新方法》中介绍了iOS5引入的关于ViewController的新方法。但是现在如果运行该文章中的Sample代码的话，你会发现Log中不会再出现viewDidUnload方法被调用的记录。这是因为在iOS6中，viewDidUnload回调方法被Deprecated掉了。查看苹果的文档，可以看到如下的说明。</p>

<!-- more -->


<p><img src="http://ww1.sinaimg.cn/large/70e1c5f8gw1e4x4y97jccj20h1051aaa.jpg" alt="image" /></p>

<p>那么，原本在viewDidUnload中的代码应该怎么处理？在iOS6中，又应该怎么处理内存警告？带着这些问题，我查找了一些资料，在此分享给大家。</p>

<h3>分析</h3>

<p>在iOS4和iOS5系统中，当内存不足，应用收到Memory warning时，系统会自动调用当前没在界面上的ViewController的viewDidUnload方法。 通常情况下，这些未显示在界面上的ViewController是UINavigationController Push栈中未在栈顶的ViewController，以及UITabBarViewController中未显示的子ViewController。这些View Controller都会在Memory Warning事件发生时，被系统自动调用viewDidUnload方法。</p>

<p>在iOS6中，由于viewDidUnload事件在iOS6下任何情况都不会被触发，所以苹果在文档中建议，应该将回收内存的相关操作移到另一个回调函数：didReceiveMemoryWarning 中。但是如果你仅仅是把以前写到viewDidUnload函数中的代码移动到didReceiveMemoryWarning函数中，那么你就错了。以下是一个 错误的示例代码 ：</p>

<p>```
&ndash; (void)didReceiveMemoryWarning {</p>

<pre><code>[super didReceiveMemoryWarning];
if([self isViewLoaded] &amp;&amp; ![[self view] window]) {
    [self setView:nil];
}
</code></pre>

<p>}
```</p>

<ol>
<li>UIView有一个CALayer的成员变量，CALayer是具体用于将自己画到屏幕上的。如下图所示：</li>
</ol>


<p><img src="http://ww1.sinaimg.cn/large/70e1c5f8gw1e4x52sbj5dj20hb06mjrs.jpg" alt="image" /></p>

<ol>
<li><p>CALayer是一个bitmap图象的容器类，当UIView调用自身的drawRect时，CALayer才会创建这个bitmap图象类。</p></li>
<li><p>具体占内存的其实是一个bitmap图象类，CALayer只占48bytes, UIView只占96bytes。而一个iPad的全屏UIView的bitmap类会占到12M的大小！</p></li>
<li><p>在iOS6时，当系统发出MemoryWarning时，系统会自动回收bitmap类。但是不回收UIView和CALayer类。这样即回收了大部分内存，又能在需要bitmap类时，通过调用UIView的drawRect: 方法重建。</p></li>
</ol>


<h3>内存优化</h3>

<p>另外文章中还提到苹果的操作系统对此做的一个内存优化技巧，解释如下：</p>

<ol>
<li><p>当一段内存被分配时，它会被标记成“In use“, 以防止被重复使用。当内存被释放时，这段内存会被标记成”Not in use”，这样，在有新的内存申请时，这块内存就可能被分配给其它变量。</p></li>
<li><p>CALayer包括的具体的bitmap内容的私有成员变量类型为CABackingStore， 当收到MemroyWarning时， CABackingStore类型的内存区会被标记成volatile类型（这里的volatile和 C以及Java语言的volatile不是一个意思），volatile表示，这块内存可能被再次被原变量重用。</p></li>
</ol>


<p>这样，有了上面的优化后，当收到Memoy Warning时，虽然所有的CALayer所包含的bitmap内存都被标记成volatile了，但是只要这块内存没有再次被复用，那么当需要重建bitmap内存时， 它就可以直接被复用，而避免了再次调用 UIView的 drawRect: 方法。</p>

<h3>总结</h3>

<p>所以，简单来说，对于iOS6，你不需要做任何以前viewDidUnload的事情，更不需要把以前viewDidUnload的代码移动到 didReceiveMemoryWarning方法中。</p>

<blockquote>
引用WWDC 2012 中的一段话来给viewDidUnload说再见：

The method viewWillUnload and viewDidUnload. We’re not going to call them anymore. I mean, there’s kind of a cost-benifit equation and analysis that we went through. In the early days, there was a real performance need for us to ensure that on memory warnings we unloaded views. There was all kinds of graphics and backing stores and so forth that would also get unloaded. We now unload those independently of the view, so it isn’t that big of a deal for us for those to be unloaded, and there were so many bugs where there would be pointers into。
</blockquote>


<h3>参考链接</h3>

<p>View Controller Lifecycle in iOS 6
CALayer Internals: Contents</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C的新特性]]></title>
    <link href="http://www.11it.com/blog/2013/05/22/objective-cde-xin-te-xing/"/>
    <updated>2013-05-22T15:43:00+08:00</updated>
    <id>http://www.11it.com/blog/2013/05/22/objective-cde-xin-te-xing</id>
    <content type="html"><![CDATA[<blockquote>
苹果在今年的WWDC2012大会上介绍了大量Objective-C的新特性，能够帮助iOS程序员更加高效地编写代码。在不久前更新的XCode4.4版本中，这些新特性已经可以使用了。让我们看看这些新特性有哪些：
</blockquote>


<h2>Object Literals</h2>

<p>这个是我认为最赞的一个改进。Object Literals允许你方便地定义数字、数组和字典对象。这个功能类似于java5提供的auto boxing功能。这虽然是一个语法糖，但我认为对提高写代码效率帮助很大。</p>

<!-- more -->


<p>让我们先来看看以前定义数字、数组和字典对象的方法：</p>

<p><code>
NSNumber * number = [NSNumber numberWithInt:1];
NSArray * array = [NSArray arrayWithObjects:@"one", @"two", nil];
NSDictionary * dict = [NSDictionary dictionaryWithObjectsAndKeys:@"value1", @"key1", @"value2", @"key2", nil];
</code></p>

<p>是不是很恶心？现在以上代码可以简化成以下形式，注意到没有，不用再在参数的最后加恶心的nil了，字典的key和value也不再是倒着先写value,再写key了：</p>

<p><code>
NSNumber * number = @1;
NSArray * array = @[@"one", @"two"];
NSDictionary * dict = @{@"key1":@"value1", @"key2":@"value2"};
</code></p>

<p>更多的示例如下：</p>

<p>```
 // 整数
  NSNumber <em>fortyTwo = @42;             // 等价于 [NSNumber numberWithInt:42]
  NSNumber </em>fortyTwoUnsigned = @42U;    // 等价于 [NSNumber numberWithUnsignedInt:42U]
  NSNumber <em>fortyTwoLong = @42L;        // 等价于 [NSNumber numberWithLong:42L]
  NSNumber </em>fortyTwoLongLong = @42LL;   // 等价于 [NSNumber numberWithLongLong:42LL]</p>

<p>  // 浮点数
  NSNumber <em>piFloat = @3.141592654F;    // 等价于 [NSNumber numberWithFloat:3.141592654F]
  NSNumber </em>piDouble = @3.1415926535;   // 等价于 [NSNumber numberWithDouble:3.1415926535]</p>

<p>  // 布尔值
  NSNumber <em>yesNumber = @YES;           // 等价于 [NSNumber numberWithBool:YES]
  NSNumber </em>noNumber = @NO;             // 等价于 [NSNumber numberWithBool:NO]</p>

<p>  // 空数组
  NSArray * array = @[];                // 等价于 [NSArray array]
  // 空的字典
  NSDictionary * dict = @{};            // 等价于 [NSDictionary dictionary]
```</p>

<p>怎么样？是不是简单多了？而且，为了方便你的旧代码迁移到新的写法，xcode专门还提供了转换工具，在xcode4.4中，选择 Edit &ndash;> Refactor &ndash;> Convert to Modern Objective-C Syntax即可。如下所示：</p>

<p><img src="http://blog.devtang.com/images/modern-objc-convert-tool.jpg" alt="" /></p>

<hr />

<h2>局部的函数调用不用前向申明</h2>

<p>这虽然是一个挺小的改进，但是很贴心。假如我们在一个源文件中有2个函数：分别名为foo 和 bar，其中foo的定义在bar前面。那如果在foo函数内部直接调用bar，编译器会报警告说找不到函数bar。</p>

<p>而现在，我们可以随意地在源文件中放置函数bar的位置。编译器在找不到bar时，会再源码后面找，如果找到了bar，就不会报错了。</p>

<h2>带有类型的enum</h2>

<p>现在我们可以定义enum是无符号整数还是整数，这样编译器会更加智能的做类型检查。如下所示：</p>

<p>```
typedef enum TableViewCellType : NSInteger {</p>

<pre><code>TableViewCellTypeQueue,
TableViewCellTypeNewFans,
TableViewCellTypeUserInfo,
TableViewCellTypeOrganization,
TableViewCellTypeFeedback,
TableViewCellTypeRateApp,
TableViewCellTypeRecommendation,
TableViewCellTypeLogout
</code></pre>

<p>}TableViewCellType;
```</p>

<h2>默认生成@synthesize代码</h2>

<p>以前写完一个诸如 @property (nonatomic, strong) NSString * username; 变量定义后，马上得转到 .m文件中去增加相应的 @synthesize username = _username; 代码。</p>

<p>现在，编辑器发现你没有写 @synthesize时，会自动帮你加上这一行。这同时在另一方面，起到了鼓励大家使用以下划线开头的变量名作为成员变量名的作用。</p>

<p>当然，为了向下兼容，如果你的程序里面已经有了 @property 变量对应的 @synthesize 代码时，编辑器就不会自动帮你增加这个代码了。</p>

<p>另外有2种特殊情况下，即使你没有写 @synthesize ，编辑器也不会自动帮你加上，这2种情况是：</p>

<p>你同时提供了该property的setter 和 getter方法。
你的这个property是 readonly 的。</p>

<h2>遍历元素</h2>

<p>你是如何遍历数组的元素的？通常我们有2种做法，一种是用 for in，另一种是用一个变量来循环数组下标。如下：</p>

<p>```
NSArray * lines = &hellip;</p>

<pre><code>for (NSString * line in lines) {
   // ...
}
for (int i = 0; i &lt; lines.count; ++i) {
    NSString * s = [lines objectAtIndex:i];
    ...
}
</code></pre>

<p>```</p>

<p>如果是字典，遍历的代码就要稍微复杂一点了：</p>

<p>```
NSDictionary * dict = …</p>

<pre><code>NSArray * keys = [dict allKeys];
for (NSString * key in keys) {
    NSString * value = [dict objectForKey:key];

}
</code></pre>

<p>```</p>

<p>现在，xcode对于iOS4.0以上的系统，支持用block来遍历元素了。用block来遍历字典可以简化代码的编写，建议大家都使用上这个新特性。</p>

<p>```
[lines enumerateObjectsUsingBlock:^(NSString * obj, NSUInteger idx, BOOL *stop) {</p>

<p>}];</p>

<p>[_urlArguments enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {</p>

<p>}];
```</p>

<h2>Subscripting Methods</h2>

<p>这个新特性在WWDC2012的视频中提到了，但是在XCode4.4中没有实现（在XCode4.5中实现了）。也是一个很体贴的语法糖，它允许你用中括号来代替原本的方法来获取和设置数组元素。</p>

<p>简单来说，以前的 [array objectAtIndex:idx] 和 [array replaceObjectAtIndex:idx withObject:obj]，可以直接写作 array[idx] 和 array[idx] = obj了。其实这个特性在很多高级语言中都实现了，只是Objective-C生于80年代，一直没改进这个。</p>

<p>以下是一些示例代码：</p>

<p>```
NSArray * array = @[ @&ldquo;111&rdquo;, @&ldquo;222&rdquo;, @&ldquo;333&rdquo;];
for (int i = 0; i &lt; 3; ++i) {</p>

<pre><code>NSLog(@"array[i] = %@", array[i]);
</code></pre>

<p>}</p>

<p>NSMutableDictionary * dict =[@{  @1: @&ldquo;value1&rdquo;,</p>

<pre><code>                             @2: @"value2",
                             @3: @"value3" } mutableCopy];
</code></pre>

<p>for (int i = 0; i &lt; 3; ++i) {</p>

<pre><code>NSLog(@"dict[%d] = %@", i, dict[@(i+1)]);
dict[@(i+1)] = [NSString stringWithFormat:@"new %@", dict[@(i+1)]];
</code></pre>

<p>}</p>

<p>[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {</p>

<pre><code>NSLog(@"dict[%@] = %@", key, dict[key]);
</code></pre>

<p>}];
```</p>

<p>这个改进同样对NSDictionary有效。甚至，你也可以给你自己的类提供中括号操作符对应的方法。具体做法是实现如下两个方法：</p>

<p><code>
- (id)objectAtIndexedSubscript:(NSUInterger)idx;
- (void)setObject:(id)value atIndexedSubscript:(NSUInteger)idx;
</code></p>

<h2>Tips</h2>

<p>上面提到了不用写 @synthesize 了，那原本写的那么多 @synthesize 怎么办呢？作为有代码洁癖的我很想把它们删掉，但怎么删呢？一个文件一个文件打开，然后行一行删掉吗？放心，苹果已经帮我们想了解决方案。在WWDC2012 Session 400 Developer Tools Kickoff 中，苹果介绍了具体做法。步骤如下：</p>

<p>首先使用区域查找，因为一般项目都会依赖第三方的开源库，我们可不想更改别人的库，所以我们只查找我们库中的文件，如下图所示：</p>

<p><img src="http://blog.devtang.com/images/modern-objc-remove-synthesize-1.png" alt="" /></p>

<ol>
<li>接着我们用正则匹配，找到以 @synthesize开头，后面接着是 var = _var; 格式的行。插入正则表达式很简单，直接点击查找输入框左边的放大镜，选择“insert pattern”，苹果就会把常见的正则表达式都列出来，你直接选择就可以了，非常方便。如下图所示：</li>
</ol>


<p><img src="http://blog.devtang.com/images/modern-objc-insert-pattern.png" alt="" /></p>

<p>在插入好合适的正则表达式后，我们按回车，就可以搜索到结果。</p>

<p><img src="http://blog.devtang.com/images/modern-objc-search-result.png" alt="" /></p>

<ol>
<li>我们点击搜索界面的preview按钮，查看替换效果，可以看到，对于我们测试代码，XCode生成的预览图已经正确地当对应代码删掉了。然后我们就可以点击替换，去掉所有的 @synthesize 代码了。</li>
</ol>


<p><img src="http://blog.devtang.com/images/modern-objc-replace-review.png" alt="" /></p>

<p>在下载完XCode4.4后，我就把我们的工程代码都转换成了新特性的语法。在转换后，我发现原本25000行的代码少了将近1000行。心里还是很开心的，因为又可以少写一些体力活类型的代码了。</p>

<p>还是那句话，希望这些新特性能够让大家玩得开心。</p>

<h2>参考资料</h2>

<ul>
<li>LLVM官方网站比较全面地介绍了 Object Literal： <a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">http://clang.llvm.org/docs/ObjectiveCLiterals.html</a></li>
<li>WWDC2012 Session 400 Developer Tools Kickoff</li>
<li>WWDC2012 Session 405 Modern Objective-C</li>
<li>WWDC2012 Session 413 Migrating to Modern Objective-C</li>
</ul>

]]></content>
  </entry>
  
</feed>
